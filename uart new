module uart_tx #(
    parameter CLKS_PER_BIT = 868 // Defaults to (100MHz / 115200 baud)
)(
    input  logic       clk,
    input  logic       rst_n,
    input  logic [7:0] tx_byte,
    input  logic       tx_dv,     // "Data Valid" pulse to start sending
    output logic       tx_active, // High while sending
    output logic       tx_serial, // The actual output pin
    output logic       tx_done    // Pulse when finished
);

    typedef enum logic [2:0] {IDLE, START, DATA, STOP, CLEANUP} state_t;
    state_t state;

    logic [15:0] clk_cnt;
    logic [2:0]  bit_idx;
    logic [7:0]  tx_data_latched;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state       <= IDLE;
            tx_serial   <= 1'b1; // UART Idle is High
            tx_done     <= 0;
            tx_active   <= 0;
            clk_cnt     <= 0;
            bit_idx     <= 0;
        end else begin
            tx_done <= 0;

            case (state)
                IDLE: begin
                    tx_serial <= 1'b1;
                    tx_active <= 0;
                    clk_cnt   <= 0;
                    bit_idx   <= 0;
                    
                    if (tx_dv == 1'b1) begin
                        tx_data_latched <= tx_byte;
                        state <= START;
                        tx_active <= 1;
                    end
                end

                // Start Bit = 0
                START: begin
                    tx_serial <= 1'b0;
                    if (clk_cnt < CLKS_PER_BIT - 1) begin
                        clk_cnt <= clk_cnt + 1;
                    end else begin
                        clk_cnt <= 0;
                        state   <= DATA;
                    end
                end

                // Data Bits (LSB first)
                DATA: begin
                    tx_serial <= tx_data_latched[bit_idx];
                    
                    if (clk_cnt < CLKS_PER_BIT - 1) begin
                        clk_cnt <= clk_cnt + 1;
                    end else begin
                        clk_cnt <= 0;
                        if (bit_idx < 7) begin
                            bit_idx <= bit_idx + 1;
                        end else begin
                            bit_idx <= 0;
                            state   <= STOP;
                        end
                    end
                end

                // Stop Bit = 1
                STOP: begin
                    tx_serial <= 1'b1;
                    if (clk_cnt < CLKS_PER_BIT - 1) begin
                        clk_cnt <= clk_cnt + 1;
                    end else begin
                        clk_cnt <= 0;
                        state   <= CLEANUP;
                        tx_done <= 1'b1;
                    end
                end

                CLEANUP: begin
                    state <= IDLE;
                end
                
                default: state <= IDLE;
            endcase
        end
    end
endmodule
