module top (
    input  logic clk,       // Mapped to PACKAGE_PIN N15 (100MHz)
    input  logic reset,     // Mapped to PACKAGE_PIN J2 
    output logic uart_txd   // Mapped to PACKAGE_PIN B16
);

    // Note: Your XDC uses 'reset' as the port name. 
    // We will use 'rst_n' internally and assume the reset signal is ACTIVE HIGH 
    // based on the common practice of FPGA reset buttons being synchronous or inverted.
    // If your reset button is active-low, you can change the line below.
    logic rst_n = ~reset; 
    
    // ==========================================
    // CONFIGURATION AREA
    // ==========================================
    localparam CLOCK_FREQ = 100000000; // 100 MHz (from XDC: period 10.000ns)
    localparam BAUD_RATE  = 115200;

    // Auto-calculated divider: 100,000,000 / 115,200 = 868.05
    localparam CLKS_PER_BIT = 868; 
    // ==========================================

    logic       tx_active;
    logic       tx_done;
    logic       tx_dv;
    logic [7:0] tx_byte;
    
    // Delay counter to send '1' roughly 10 times per second
    logic [31:0] delay_cnt;
    localparam DELAY_CYCLES = CLOCK_FREQ / 10; // 0.1 second delay

    // State machine to handle the repetition
    typedef enum logic [1:0] {IDLE, TRANSMIT, DELAY} state_t;
    state_t state;

    // Instantiate the UART Transmitter
    // We pass the calculated CLKS_PER_BIT to the module
    uart_tx #(.CLKS_PER_BIT(CLKS_PER_BIT)) u_tx (
        .clk(clk),
        .rst_n(rst_n),
        .tx_byte(tx_byte),
        .tx_dv(tx_dv),
        .tx_active(tx_active),
        .tx_serial(uart_txd),
        .tx_done(tx_done)
    );

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state     <= IDLE;
            tx_dv     <= 0;
            tx_byte   <= 8'h00;
            delay_cnt <= 0;
        end else begin
            // Default to no action
            tx_dv <= 0;

            case (state)
                IDLE: begin
                    // Prepare the data: ASCII '1' is hex 0x31
                    tx_byte <= 8'h31; 
                    
                    // Trigger the UART for one clock cycle
                    tx_dv   <= 1'b1;
                    state   <= TRANSMIT;
                end

                TRANSMIT: begin
                    // Wait for the UART module to finish (tx_done pulse)
                    if (tx_done) begin
                        delay_cnt <= 0;
                        state <= DELAY;
                    end
                end

                DELAY: begin
                    // Wait 0.1s before sending again
                    if (delay_cnt < DELAY_CYCLES) begin
                        delay_cnt <= delay_cnt + 1;
                    end else begin
                        delay_cnt <= 0;
                        state     <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule
